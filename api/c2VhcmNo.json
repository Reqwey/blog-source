[{"title":"【English】如何描写各种动物的叫声","date":"2024-01-28T16:08:00.000Z","date_formatted":{"ll":"Jan 28, 2024","L":"01/28/2024","MM-DD":"01-28"},"updated":"2024-01-28T08:21:50.966Z","content":"（转载自 如何用英文描写动物们的声音_沪江英语学习网）\n\nA cat miaows /mews/purrs.猫“喵喵”叫。\n狗是怎么叫的呢？我们最常用的一个词就是bark. bark除了有“犬吠”的意思外，还有“树皮”的意思，这在GRE考试中还考到过。另外描述狗叫的还有yap（汪汪叫）想一下不停的狗吠是不是很招人烦，所以yap这个词另外的意思就是“吵嚷”。另外 yelp 和 snarl 也是常用来形容狗叫的。\nA dog yaps/ yelps/ barks/ snarls.狗吠。\nA duck quacks.鸭子叫。\nquack这个词除了用来形容鸭子叫之外还可以用来指 “江湖医生，庸医。”记住了这个quack害人真是不浅呀。\nA cock crows.公鸡啼。\n这个crow的意义可非同一般，“公鸡啼鸣”它表示新的一天又开始了。\n还记得红楼梦里薛蟠哼的那首打油诗吗？“一个苍蝇嗡啊嗡，一个蚊子哼啊哼。”它们的声音听起来真是令人讨厌。英语里又是用什么词来形容它们的声音呢？只要这两个词就可以了：buzz(嗡嗡)hum（哼哼）\nA fly hums/ buzzes/ drones.苍蝇“嗡嗡”叫。\nA bee/ mosquito hums/ buzzes.蜂/蚊子“嗡嗡”叫。\n在这里只好委屈美好和勤劳的小蜜蜂了。谁让它的叫声和它俩差不多呢？这里 hum除了尤指蜜蜂发“嗡嗡”(a continuous buzz)声，发“哼哼”声外，还可以用来指人等“闭嘴哼唱”，如：hum a song 哼一首歌。\n下面我就再给你列出一些常见的动物的声音，有兴趣的话就仔细看看吧！\nA chick cheeps/ pips/ pules/ peeps.小鸡“叽叽”叫。\nA bird/ sparrow twitters /chirps/ chirrups.鸟/麻雀“唧唧喳喳”叫。\nA rat squeaks.耗子“唧唧”叫。\nA mouse squeaks/ peeps.老鼠“吱吱”叫。\nA calf/lamb/goat bleats.小牛/小羊/山羊叫。\nA sheep bleats/ baas.绵羊&quot;咩咩&quot;叫。\nAn ass/donkey brays.驴叫。\nA wild - goose honks.雁鸣。\n不知你注意到了没有这里的雁叫声竟然是honk。这个声音我们并不陌生，生活在大城市的人们几乎每天都受汽车喇叭声的折磨。这个honk就是 “（按）汽车喇叭声”的意思。\nAs she drove past, she honked the horn.\n她开车经过时，按了喇叭。可想而知大雁的声音是怎么样的了。\nBellow这个词常常用来指公牛吼叫，试着模仿一下那“巨大低沉的吼声”（a loud deep hollow sound）。也可以用在人身上，如：to bellow (out) with excitement/pain兴奋得/痛得大声吼叫，to bellow (out) orders 意思是大声发出命令。“Go away!” He bellowed.“滚开！”他吼叫道。\n下面就来听一场森林交响曲，让你对动物们的声音更加熟悉：\nA crow caws /craoks.乌鸦叫。\nA crane whoops.鹤叫。\nA magpie chatters.喜鹊“嘁嘁喳喳”叫。\nA nightingale jugs.夜莺叫。\nA frog croaks.青蛙“呱呱”叫。\nA goose cackles/ gaggles.鹅“嘎嘎”叫。\nA dove/ pigeon coos/ croods/ croodles.鸽子“咕咕”叫。\nA bear/bull bellows.熊/公牛吼叫。\nAn elephant trumpets.大象吼叫。\nA fox yelps.狐狸叫。\nA lion roars.狮吼。\nA monkey screeches/ chatters/ gibbers.猴子“喳喳”叫。\nA snake hisses.蛇嘶嘶。\nA tiger growls.虎咆哮。\nA turkey gobbles.火鸡叫。\nA whale blows.鲸啸。\nA wolf howls.狼嚎\n","plink":"https://oi.reqwey.me/youth-career-gpt-4/"},{"title":"热学笔记","date":"2023-06-28T00:00:00.000Z","date_formatted":{"ll":"Jun 28, 2023","L":"06/28/2023","MM-DD":"06-28"},"updated":"2024-01-28T08:21:50.966Z","content":"\n","plink":"https://oi.reqwey.me/heat-physics/"},{"title":"【Whk Note】生物记忆内容","date":"2023-01-09T19:37:00.000Z","date_formatted":{"ll":"Jan 9, 2023","L":"01/09/2023","MM-DD":"01-09"},"updated":"2024-01-28T08:21:50.962Z","content":"各种杂七杂八的记忆内容\n\n外界中的O2进入红细胞内共穿过几层生物膜\n5 层\n\n外界中的O2要经过肺泡壁（进和出,一层细胞2层膜）、毛细血管壁（进和出,一层细胞2层膜）、红细胞膜（1层膜）才能进入红细胞内\n\n外界中的O2进入组织细胞内共穿过几层生物膜\n\n如果是植物，至少3层：细胞膜—线粒体外膜—线粒体内膜\n\n\n如果是动物或者人，至少11层：肺泡细胞（穿过整个上皮细胞，所以2层）—毛细血管壁细胞（同上，2层）—红细胞（一进一出，2层）—毛细血管壁细胞（同上，2层）—组织细胞的细胞膜（1层）—线粒体外膜（1层）—线粒体内膜（1层）。\n\n持续更新。。。\n","plink":"https://oi.reqwey.me/biology-note/"},{"title":"【Whk Note】各种化学键的强弱","date":"2023-01-09T19:37:00.000Z","date_formatted":{"ll":"Jan 9, 2023","L":"01/09/2023","MM-DD":"01-09"},"updated":"2024-01-28T08:21:50.962Z","content":"影响各种化学键的强弱的主要因素\n\n离子键\n专有名词：晶格能\n\n离子键两端原子的大小：距离越小,离子键越稳定\n价电子数：越多离子键越稳定\n\n补充：\n【晶格能的概念】\n在反应时 1mol 离子化合物中的阴、阳离子从相互分离的气态结合成离子晶体时所放出的能量．或破坏 1mol 晶体，使它变成完全分离的气态自由离子所需要消耗的能量．\n【晶格能的影响因素】\n\n离子半径：阴阳离子半径越小，离子键越强，晶格能越大，例如，随着卤离子半径增大，卤化物的晶格能降低；\n离子电荷：离子电荷越多，离子键越强，晶格能越大；\n电子构型：\n\\text{Cu}^+\n\n\n\n\n\n\n \n \n \n\n 和 \n\\text{Na}^+\n\n\n\n\n\n\n \n \n \n\n 半径相近、离子电荷相同，但 \n\\text{Cu}^+\n\n\n\n\n\n\n \n \n \n\n 是18电子构型，对阴离子会产生极化作用，因此晶格能：\n\\text{Cu}_2\\text{S}＜\\text{Na}_2\\text{S}\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n＜\n\n\n \n \n \n\n \n\n．\n\n【晶格能的应用】\n判断晶体的稳定性．晶格能越大，离子键越强，晶体越稳定．\n共价键\n专有名词：键长、键能、电子云重合\n\n原子间的核间距（成键原子半径）：越小共价键越强\n共用电子对数：越多越强\n\n\n大 \n\\pi\n\n\n\n\n \n\n键：\n\\Pi_n^m\n\n\n\n\n\n\n \n \n \n\n n 原子数，m 总电子数\n\n金属键\n【基本概念】\n金属键就是金属离子和自由电子之间的强烈的相互作用．存在于金属单质和合金中．成键微粒是金属阳离子和自由电子；\n【影响因素】\n\n金属元素的原子半径\n单位体积内自由电子的数目\n\n一般而言：金属元素的原子半径越小，单位体积内自由电子数目越大，金属键越强，金属晶体的硬度越大，熔、沸点越高．如：同一周期金属原子半径越来越小，单位体积内自由电子数增加，故熔点越来越高，硬度越来越大；同一主族金属原子半径越来越大，单位体积内自由电子数减少，故熔点越来越低，硬度越来越小．\n对比：\n\n\n分子间作用力\n范德华力\n\n课本：一般随相对分子质量增大而增大\n\n影响：熔点、沸点、溶解度等\n氢键\n\n定义：某些氢化物的分子之间存在着一种比分子间作用力稍强的相互作用，使它们只能在较高的温度下才能汽化，这种相互作用叫做氢键．常见易形成氢键的化合物：\n\\text{HF}\n\n\n\n\n\n \n \n\n、\n\\text{H}_2\\text{O}\n\n\n\n\n\n\n \n \n \n\n、\n\\text{N}\\text{H}_3\n\n\n\n\n\n\n \n\n \n \n\n\n等．\n特点：\n①有方向性和饱和性；\n②氢键的键能比化学键能小，比分子间作用力稍强．因此氢键不属于化学键，其强度比化学键弱得多，又不属于分子间力（范德华力），但它比分子间作用力稍强．\n通式：\n氢键结合的情况可用X-H…Y表示．式中X和Y代表F，O，N等电负性大而原子半径较小的非金属原子．X和Y可以是两种相同的元素，也可以是两种不同的元素．\n氢键作用：\n（1）增强分子间溶解度，例如：1体积水中可溶解700体积氨气．\n（2）分子内氢键使物质熔沸点降低。\n\n","plink":"https://oi.reqwey.me/bond-strength/"},{"title":"开发备忘录","date":"2022-12-01T00:00:00.000Z","date_formatted":{"ll":"Dec 1, 2022","L":"12/01/2022","MM-DD":"12-01"},"updated":"2024-01-28T08:21:50.962Z","content":"Windows 下 SSH / Git 配置代理\n在 C:\\Users\\reqwey\\.ssh 目录下新建 config 文件，并写入以下内容：(其中 6666 是代理软件的端口）\n123456789101112131415161718192021#Windows用户，注意替换你的端口号和connect.exe的路径ProxyCommand &quot;D:\\Program Files\\Git\\mingw64\\bin\\connect&quot; -S 127.0.0.1:6666 -a none %h %p#MacOS用户用下方这条命令，注意替换你的端口号#ProxyCommand nc -v -x 127.0.0.1:6666 %h %pHost github.com  User git  Port 22  Hostname github.com  # 注意修改路径为你的路径  IdentityFile &quot;C:\\Users\\reqwey\\.ssh\\id_rsa&quot;  TCPKeepAlive yesHost ssh.github.com  User git  Port 443  Hostname ssh.github.com  # 注意修改路径为你的路径  IdentityFile &quot;C:\\Users\\reqwey\\.ssh\\id_rsa&quot;  TCPKeepAlive yes\nSocket.io server 4.x 遍历已连接的所有 Socket\n1for (let [id, socket] of io.sockets.sockets) &#123;&#125;\n其中 io.sockets.sockets 为 Map。单独取一个需要使用 .get(socket_id) 语法\n国内 Electron 安装失败\n\n使用 yarn install 而不是 npm install\n修改 node_modules/electron/install.js 内容如下\n\n123456789101112downloadArtifact(&#123;  version,  artifactName: &#x27;electron&#x27;,  force: process.env.force_no_cache === &#x27;true&#x27;,  cacheRoot: process.env.electron_config_cache,  checksums: process.env.electron_use_remote_checksums ? undefined : require(&#x27;./checksums.json&#x27;),+ mirrorOptions: &#123;+   mirror: &#x27;https://cdn.npmmirror.com/binaries/electron/&#x27;+ &#125;,  platform,  arch&#125;).then(extractFile).catch(err =&gt; &#123;\n","plink":"https://oi.reqwey.me/dev-utils/"},{"title":"【Solution】ABC 246 Ex. 01? Queries","date":"2022-04-07T00:00:00.000Z","date_formatted":{"ll":"Apr 7, 2022","L":"04/07/2022","MM-DD":"04-07"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门 (Translated by me.)\n\n令 \nf_{i,0/1}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n 表示以字符串前 \ni\n\n\n\n\n \n\n 个字符构成的所有不同子序列中以 \n0/1\n\n\n\n\n\n\n \n \n \n\n 结尾的子序列的个数。\n对于当前字符 \ns_i=\n\n\n\n\n\n\n \n \n \n\n 0 \n\\texttt{or}\n\n\n\n\n\n \n \n\n 1  \n\\texttt{or}\n\n\n\n\n\n \n \n\n ?，有不同的转移方式，以下先说明 \ns_i=\n\n\n\n\n\n\n \n \n \n\n 0 的情况：\n\n首先令 \nf_{i,0} \\leftarrow f_{i-1,0},\\ f_{i,1} \\leftarrow f_{i-1,1}\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n\n。即不考虑 \ns_i\n\n\n\n\n\n \n \n\n 作为结尾，直接继承上一个集合。\n考虑由 \ns_i\n\n\n\n\n\n \n \n\n 结尾的子序列有多少相对于 \nf_{i-1,0}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n 的集合是没有出现过的。\n考虑容斥，先求出结尾接上 \ns_i\n\n\n\n\n\n \n \n\n 可以成为满足条件的子序列总共有 \nf_{i-1,0}+f_{i-1,1}+1\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n 个（\n+1\n\n\n\n\n\n \n \n\n 表示空串）。\n然后考虑接上 \ns_i\n\n\n\n\n\n \n \n\n 后还是在集合 \nf_{i-1,0}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n 中的子序列的个数。\n由于在 \ns_{1\\sim (i-1)}\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n \n \n\n\n 中 \n0\n\n\n\n\n \n\n 是连续分布的，所以，集合 \nf_{i-1,0}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n 中的其他的子序列去掉末尾的 \n0\n\n\n\n\n \n\n 再接上位置 \ni\n\n\n\n\n \n\n 上的 \n0\n\n\n\n\n \n\n 都可以表示为该集合中的元素。\n因此最终答案为 \nf_{i-1,0}+[(f_{i-1,0}+f_{i-1,1}+1)-f_{i-1,0}]=f_{i-1,0}+f_{i-1,1}+1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n \n \n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n \n \n\n \n\n \n \n \n \n \n\n\n \n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n\n因此，我们一共可以写出：\n\nf_{i,0}\\leftarrow f_{i-1,0}+f_{i-1,1}+1\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n\n\nf_{i,1}\\leftarrow f_{i-1,1}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n\n\n\n同样，当  \ns_i=\n\n\n\n\n\n\n \n \n \n\n 1 时，\n\nf_{i,0}\\leftarrow f_{i-1,0}\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n\n\n\nf_{i,1}\\leftarrow f_{i-1,0}+f_{i-1,1}+1\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n\n当 \ns_i=\n\n\n\n\n\n\n \n \n \n\n ? 时，\n\nf_{i,0}\\leftarrow f_{i-1,0}+f_{i-1,1}+1\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n\n\nf_{i,1}\\leftarrow f_{i-1,0}+f_{i-1,1}+1\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n\n然后去看 Editorial - AtCoder Beginner Contest 246。\nCode\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/*思路：*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define debug(...) fprintf(stderr, __VA_ARGS__)#define Debug(...)                                                  \\  fprintf(stderr, &quot;Line %d, func %s() : &quot;, __LINE__, __FUNCTION__), \\      fprintf(stderr, __VA_ARGS__)      typedef long long ll;#define IL inlineusing std::cerr;using std::cin;using std::cout;using std::endl;using std::ios;using std::string;namespace IO &#123;template &lt;typename T&gt;IL void read(T &amp;x) &#123;  T r = 1;  char ch = cin.get();  for (; !isdigit(ch); ch = cin.get()) r = (ch == &#x27;-&#x27; ? -1 : 1);  for (x = 0; isdigit(ch); ch = cin.get()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - &#x27;0&#x27;;  x *= r;&#125;template &lt;typename T, typename... Args&gt;void read(T &amp;x, Args &amp;...args) &#123;  read(x), read(args...);&#125;template &lt;typename T&gt;IL void write(T x) &#123;  if (x &lt; 0) cout.put(&#x27;-&#x27;), x = -x;  if (x &gt; 9) write(x / 10);  cout.put(x % 10 + &#x27;0&#x27;);&#125;&#125;  // namespace IOusing namespace IO;const int N = 2e5 + 10, MOD = 998244353;template&lt;typename T&gt; IL void cmax(T &amp;a, T b) &#123; a &lt; b ? (a = b) : 0; &#125;template&lt;typename T&gt; IL void cmin(T &amp;a, T b) &#123; a &gt; b ? (a = b) : 0; &#125;int add(int a, int b) &#123; return (a + b &gt;= MOD) ? (a + b - MOD) : (a + b); &#125;int sub(int a, int b) &#123; return add(a, MOD - b); &#125;int mul(int a, int b) &#123; return 1ll * a * b % MOD; &#125;struct Matrix &#123;  int a[3][3];  Matrix() &#123; memset(a, 0, sizeof a); &#125;  friend Matrix operator*(Matrix A, Matrix B) &#123;    Matrix C;    for (int k = 0; k &lt; 3; ++k)      for (int i = 0; i &lt; 3; ++i)        for (int j = 0; j &lt; 3; ++j)          C.a[i][j] = add(C.a[i][j], mul(A.a[i][k], B.a[k][j]));    return C;  &#125;&#125; mat0, mat1, matq, f, E;IL void init() &#123;  f.a[2][0] = 1;  mat0.a[0][0] = 1; mat0.a[0][1] = 1; mat0.a[0][2] = 1;  mat0.a[1][1] = 1; mat0.a[2][2] = 1;  mat1.a[0][0] = 1; mat1.a[1][0] = 1; mat1.a[1][1] = 1;  mat1.a[1][2] = 1; mat1.a[2][2] = 1;  matq.a[0][0] = 1; matq.a[0][1] = 1; matq.a[0][2] = 1;  matq.a[1][0] = 1; matq.a[1][1] = 1; matq.a[1][2] = 1;  matq.a[2][2] = 1;      E.a[0][0] = 1; E.a[1][1] = 1; E.a[2][2] = 1;&#125;string s;int n, q;class SegT &#123; public:  Matrix arr[N &lt;&lt; 2];  SegT() &#123;&#125;    IL void modify(Matrix &amp;a, char c) &#123;  \tswitch (c) &#123;  \t\tcase &#x27;0&#x27;: a = mat0; break;  \t\tcase &#x27;1&#x27;: a = mat1; break;  \t\tcase &#x27;?&#x27;: a = matq; break;  \t\tdefault: cerr &lt;&lt; &quot;fuck&quot; &lt;&lt; endl; break;  \t&#125;  &#125;    #define pushup arr[id] = arr[id &lt;&lt; 1] * arr[id &lt;&lt; 1 | 1]  void build(int id, int l, int r) &#123;    if (l == r) &#123;    \tmodify(arr[id], s[l - 1]);    \treturn;    &#125;    int mid = (l + r) &gt;&gt; 1;    build(id &lt;&lt; 1, l, mid), build(id &lt;&lt; 1 | 1, mid + 1, r);    pushup;  &#125;    void insert(int id, int l, int r, int X, char c) &#123;  \tif (X &lt; l || r &lt; X) return;  \tif (l == r) &#123; modify(arr[id], c); return; &#125;  \tint mid = (l + r) &gt;&gt; 1;  \tinsert(id &lt;&lt; 1, l, mid, X, c), insert(id &lt;&lt; 1 | 1, mid + 1, r, X, c);  \tpushup;  &#125;&#125; tree;signed main() &#123;  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);  init();  read(n, q);  cin &gt;&gt; s;  tree.build(1, 1, n);\tfor (int i = 1, pos; i &lt;= q; ++i) &#123;\t\tchar c;\t\tread(pos); c = cin.get();\t\ttree.insert(1, 1, n, pos, c);\t\tMatrix tmp = tree.arr[1] * f;\t\twrite(add(tmp.a[0][0], tmp.a[1][0])); cout.put(&#x27;\\n&#x27;);\t&#125;  return 0;&#125;\n","plink":"https://oi.reqwey.me/solution-abc246-ex/"},{"title":"【Solution】AtCoder Edu DP Round 两道","date":"2022-03-10T00:00:00.000Z","date_formatted":{"ll":"Mar 10, 2022","L":"03/10/2022","MM-DD":"03-10"},"updated":"2024-01-28T08:21:50.966Z","content":"比赛传送门。\n\nV. Subtree-换根 DP\n题目传送门。\nDown\n\n\\text{down}(v)=\\prod \\limits_{u\\ v连边} (\\text{down}(u)+1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n \n\n \n \n\n连\n\n\n边\n\n\n\n \n\n \n \n \n \n\n \n \n \n \n \n \n\n\nUp\n由于模数不一定质数，不能用除法，因此正着乘一遍，反着乘一遍就好。\n123456789101112131415void up(int u, int rt) &#123;\tll tmp = f[u][1];\tfor (ui i = 0; i &lt; g[u].size(); ++i) if (g[u][i] != rt) &#123;\t\tf[g[u][i]][1] *= tmp %= m;\t\t(tmp *= (f[g[u][i]][0] + 1)) %= m;\t&#125;\ttmp = 1;\tfor (ui i = g[u].size() - 1; ~i; --i) if (g[u][i] != rt) &#123;\t\tf[g[u][i]][1] *= tmp %= m;\t\t(tmp *= (f[g[u][i]][0] + 1)) %= m;\t&#125;\tfor (auto &amp;v : g[u]) if (v != rt) &#123;\t\t++f[v][1]; up(v, u);\t&#125; &#125;\nW. Intervals-线段树优化 DP\n题目传送门。\n按右端点从小到大排序，将 \n[1,i-1]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 状态集合里面取个最大值加到该点对应的线段树中，然后把右端点 \n=i\n\n\n\n\n\n \n \n\n 的区间加入线段树中，表示他能对之前的一些状态产生影响。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int n, m;struct req &#123;\tint l, r; ll w;&#125; a[N];ll tree[N &lt;&lt; 2], tag[N &lt;&lt; 2];IL void cmax(ll &amp;a, ll b) &#123; a &lt; b ? (a = b) : 0; &#125;IL void pushdown(int x) &#123;\tif (tag[x]) &#123;\t\ttree[x &lt;&lt; 1] += tag[x], tag[x &lt;&lt; 1] += tag[x];\t\ttree[x &lt;&lt; 1 | 1] += tag[x], tag[x &lt;&lt; 1 | 1] += tag[x];\t\ttag[x] = 0;\t&#125;&#125;void insert(int x, int l, int r, int L, int R, ll w) &#123;\tif (L &lt;= l &amp;&amp; r &lt;= R) &#123; tree[x] += w, tag[x] += w; &#125;\telse &#123;\t\tpushdown(x);\t\tint mid = (l + r) &gt;&gt; 1;\t\tif (L &lt;= mid) insert(x &lt;&lt; 1, l, mid, L, R, w);\t\tif (R &gt; mid) insert(x &lt;&lt; 1 | 1, mid + 1, r, L, R, w);\t\ttree[x] = std::max(tree[x &lt;&lt; 1], tree[x &lt;&lt; 1 | 1]);\t&#125;&#125;ll query(int x, int l, int r, int L, int R) &#123;\tif (L &lt;= l &amp;&amp; r &lt;= R) return tree[x];\telse &#123;\t\tpushdown(x);\t\tint mid = (l + r) &gt;&gt; 1;\t\tll ans = -INT64_MAX;\t\tif (L &lt;= mid) cmax(ans, query(x &lt;&lt; 1, l, mid, L, R));\t\tif (R &gt; mid) cmax(ans, query(x &lt;&lt; 1 | 1, mid + 1, r, L, R));\t\treturn ans;\t&#125;&#125;int main() &#123;\tstd::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);\tstd::cin &gt;&gt; n &gt;&gt; m;\tfor (int i = 1; i &lt;= m; ++i)\t\tstd::cin &gt;&gt; a[i].l &gt;&gt; a[i].r &gt;&gt; a[i].w;\tstd::sort(a + 1, a + m + 1, [](req x, req y) &#123; return x.r &lt; y.r; &#125;);\tfor (int i = 1, j = 1; i &lt;= n; ++i) &#123;\t\tinsert(1, 1, n, i, i, query(1, 1, n, 1, i));\t\twhile (a[j].r == i &amp;&amp; j &lt;= m) insert(1, 1, n, a[j].l, a[j].r, a[j].w), ++j;\t&#125;\tstd::cout &lt;&lt; std::max(0LL, query(1, 1, n, 1, n));\treturn 0;&#125;\n","plink":"https://oi.reqwey.me/solution-atc-dp-1/"},{"title":"【Solution】Almost Sorted-状压DP","date":"2022-03-09T00:00:00.000Z","date_formatted":{"ll":"Mar 9, 2022","L":"03/09/2022","MM-DD":"03-09"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n\n诊断分析\n我们发现 \nn\n\n\n\n\n \n\n 比较大，直接 \n2^n\n\n\n\n\n\n \n \n\n 暴力肯定不行，想着 \nd\n\n\n\n\n \n\n 很小，能不能有什么性质和判定。\n我们发现，位置 \ni\n\n\n\n\n \n\n 只能选 \n[i-d,i+d]\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n ，意味着状态只有 \n2d+1\n\n\n\n\n\n\n\n \n \n \n \n\n 种。\n能力测评\n假设 \n1 \\sim i-1\n\n\n\n\n\n\n\n \n \n \n \n \n\n 构成状压集合 \n\\texttt{S}\n\n\n\n\n \n\n，表示 \n[(i-1)-d,(i-1)+d]\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n 内的选数情况。\n我们要保证一件事，就是 \n\\texttt{S &amp; 1 = 1}\n\n\n\n\n\n\n\n \n \n \n \n \n\n  。因为 \ni\n\n\n\n\n \n\n 够不着 \ni-d-1\n\n\n\n\n\n\n\n \n \n \n \n \n\n。\n然后取 \n\\texttt{S' = S &gt;&gt; 1}\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 表示  \n[i-d,i+d]\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n 内的选数情况。\n在进行内层循环 \nj\\in [0,d+d]\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n。必须满足 \nj \\notin S\n\n\n\n\n\n\n \n \n \n\n。\n分两种情况讨论：\n\n\na_i\\neq -1\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n：如果 \na_i=i+(d-j)\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n 那么就直接把 \nf(i,S'\\cup\\{a_i\\})\\leftarrow f(i,S'\\cup\\{a_i\\})+f(i-1,S)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n \n \n\n \n \n\n \n \n \n \n \n \n \n\n \n \n\n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n\n。\n\na_i=-1\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n：同样 \nf(i,S'\\cup\\{i+(d-j)\\})\\leftarrow f(i,S'\\cup\\{i+(d-j)\\})+f(i-1,S)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n。\n\n课堂小结\n1234567891011121314151617181920212223242526272829const int N = 514, D = (1 &lt;&lt; (1 + 4 + 5 + 1)) + 4;const ll MOD = 998244353;int a[N];ll f[N][D];int n, d;IL void madd(ll &amp;a, ll b) &#123; a = (a + b) % MOD; &#125;IL void cmax(ll &amp;a, ll b) &#123; a &lt; b ? (a = b) : 0; &#125;int main() &#123;\tstd::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);\tstd::cin &gt;&gt; n &gt;&gt; d;\tfor (int i = 1; i &lt;= n; ++i)\t\tstd::cin &gt;&gt; a[i], --a[i]; // 方便状压\tf[0][(1 &lt;&lt; (d + 1)) - 1] = 1; // 代表比他小的都选完了，注意不是 0\tfor (int i = 1; i &lt;= n; ++i) &#123;\t\tfor (int set = 1; set &lt; 1 &lt;&lt; (d + d + 1); set += 2) &#123;\t\t// 从 1 开始，+= 2 确保最左一位始终为 1，是合法的\t\t\tint newset = set &gt;&gt; 1;\t\t\tfor (int j = 0; j &lt;= d + d; ++j) &#123;\t\t\t\tif (a[i] &gt;= 0 &amp;&amp; a[i] != i - 1 + j - d) continue;\t\t\t\telse if (~newset &amp; (1 &lt;&lt; j)) madd(f[i][newset | (1 &lt;&lt; j)], f[i - 1][set]);\t\t\t&#125;\t\t&#125;\t&#125;\tstd::cout &lt;&lt; f[n][(1 &lt;&lt; (d + 1)) - 1]; // 代表比他小的都选完了，注意不是 0\treturn 0;&#125;\n","plink":"https://oi.reqwey.me/solution-arc132-c/"},{"title":"【Solution】Nauuo and Binary Tree-重链剖分","date":"2022-03-07T00:00:00.000Z","date_formatted":{"ll":"Mar 7, 2022","L":"03/07/2022","MM-DD":"03-07"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n\n首先将每个点与 \n1\n\n\n\n\n \n\n 号点进行一次询问，求出每个节点的深度，然后按照其深度进行分层。（方便划分子问题）\n假设你已经做完了以 \n1\n\n\n\n\n \n\n 为根的上面一坨，现在要求第 \ni\n\n\n\n\n \n\n 个点的父亲是谁。\n我们先把上面一坨拿来重链剖分，找到链底端节点，然后根据 \n\\texttt{LCA}\n\n\n\n\n\n\n \n \n \n\n 深度的性质跳到他们的 \n\\texttt{LCA}\n\n\n\n\n\n\n \n \n \n\n。\n如图：\n\n设这个点为 \nv\n\n\n\n\n \n\n 。然后我们跳到他的非重儿子。设为 \nw\n\n\n\n\n \n\n。\n那么我们相当于只要在 \nw\n\n\n\n\n \n\n 为根的一坨中寻找他的父亲，这就变成了子问题。\n当发现 \nw\n\n\n\n\n \n\n 没有子节点的时候，你就把它挂上去，结束了。\n时间复杂度分析：跳一次轻边子树大小至少 \n/2\n\n\n\n\n\n \n \n\n ，因此不超过 \n\\log(n)\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n 次就能找到父亲。\n12345678910111213141516171819IL void solve(int j, int r) &#123;  if (!p[r][0]) &#123;    addEdge(r, j);    return;  &#125;  int d1 = que(bot[r], j);  int v = bot[r];  while (dep[v] &lt;&lt; 1 &gt; dep[j] + dep[bot[r]] - d1)    v = fa[v];  int s = p[v][!son[v]];  if (s)    solve(j, s);  else    addEdge(v, j);&#125;\n完整代码\n","plink":"https://oi.reqwey.me/solution-libre-6669/"},{"title":"【Solution】 [CEOI2016]kangaroo-DP","date":"2022-03-04T00:00:00.000Z","date_formatted":{"ll":"Mar 4, 2022","L":"03/04/2022","MM-DD":"03-04"},"updated":"2024-01-28T08:21:50.966Z","content":"原题传送门\n\n即要构造这样的数列，满足 \na_{i-1} &lt; a_i &gt; a_{i+1}\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n \n\n \n\n \n\n \n \n \n\n\n\n 即 ^ 或 \na_{i-1} &gt; a_i &lt; a_{i+1}\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n \n\n \n \n\n \n\n \n\n \n \n \n\n\n\n 即 v。\n我们考虑按从小到大的顺序插入。设此时已经做好了一些段。由于新插入的数总比之前的任何数大，因此会出现一个^。为了保证布局合法，我们必须要保证之前的段都是以 /...\\ 的形式。\n具体来说，设 \nf(i,j)\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n 为已经做到第 \ni\n\n\n\n\n \n\n 位，分了 \nj\n\n\n\n\n \n\n 段的方案数。\n分类讨论：\n\n\ni\\neq s, i\\neq t\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n ：\n\n连接两个段：\nf(i-1,j+1)\\times j\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n\n\n新开一段：\nf(i-1,j)\\times c\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n。其中，若 \ni&gt;s\n\n\n\n\n\n\n \n \n \n\n 则不能开在头，\ni&gt;t\n\n\n\n\n\n\n \n \n \n\n 则不能开在尾。因此 \nc=j+1-[i&gt;s]-[i&gt;t]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n\ni=s\\ \\texttt{or}\\ i=t\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n \n \n \n\n ：\n\n接在头、尾：\nf(i-1,j)\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n\n开在头、尾：\nf(i-1,j-1)\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n\n\n\n\n注：当\ni\\neq s, i\\neq t\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 时我们只存在连接两个段和新开这两种操作，而没有只贴在一边。因为如果贴在原来的一段的边界上就会出现上扬，即 \\... 或 .../ 这种情况，与题设条件矛盾。\n1234567891011IL void work() &#123;\tf[0][0] = 1;\tfor (int i = 1; i &lt;= n; ++i)\t\tfor (int j = 1; j &lt;= n; ++j)\t\t\tif (i != s &amp;&amp; i != t) &#123;\t\t\t\tf[i][j] = (f[i - 1][j + 1] * j % MOD + f[i - 1][j - 1] * (j - (i &gt; s) - (i &gt; t)) % MOD) % MOD;\t\t\t&#125; else &#123;\t\t\t\tf[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) % MOD;\t\t\t&#125;\tstd::cout &lt;&lt; f[n][1];&#125;\n","plink":"https://oi.reqwey.me/solution-luogu-5999/"},{"title":"【Solution】[NOI Online 2 提高组]子序列问题-线段树","date":"2022-03-01T00:00:00.000Z","date_formatted":{"ll":"Mar 1, 2022","L":"03/01/2022","MM-DD":"03-01"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n\n题目要我们求解 \n\\Sigma{((f(l,r))^2)}\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n \n \n \n\n \n \n\n \n\n\n，于是我们构造一个 \ng(l,r)\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n 使得\n\ng(l,r)=\\frac{f(l,r)\\times(f(l,r)+1)}{2}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n\n\n\n\n这样，会有\n\n(f(l,r))^2=2g(l,r)-f(l,r)\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n然后我们只需要分别求解 \ng\n\n\n\n\n \n\n 和 \nf\n\n\n\n\n \n\n\n定义 \nlast_i\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n\n 表示与 \nA_i\n\n\n\n\n\n \n \n\n 相等的最近一个 \nA_j\n\n\n\n\n\n \n \n\n 的下标 \nj\n\n\n\n\n \n\n。特别地，若没有，则为 \n0\n\n\n\n\n \n\n。\n我们有以下性质：\n\n\\sum_{l=1}^{r+1}{f(l,r+1)}=\\sum_{l=1}^{r}{f(l,r)}+\\sum_{l=last_{r+1}+1}^{r+1}{1}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n \n \n\n\n \n \n \n \n \n \n \n \n\n \n\n \n\n \n \n \n\n \n\n\n \n \n \n \n \n \n\n \n\n \n\n \n \n \n \n \n\n \n\n \n \n \n\n\n \n \n\n\n \n \n \n\n\n \n\n\n这是因为加入一个 \nA_{r+1}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n 时，只有当 \nl\\in[last_{r+1}+1,r+1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n \n\n \n \n \n\n\n \n \n \n \n \n \n \n\n 时，区间 \n[l,r+1]\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 中才会认为 \nA_{r+1}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n 一个新的值（在这之外的值会认为是重复的），会导致\nf(l,r)\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n 的值 \n+1\n\n\n\n\n\n \n \n\n。\n遍历区间右端点 \nr\n\n\n\n\n \n\n，同时构造一棵线段树，它维护的区间 \n[1,n]\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 存储 \nf(1,r) \\sim f(n,r)\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n 的值。当 \nr\n\n\n\n\n \n\n 变为 \nr+1\n\n\n\n\n\n\n \n \n \n\n 时，\n[last_{r+1}+1,r+1]\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n\n \n \n \n\n\n \n \n \n \n \n \n \n\n 区间 \n+1\n\n\n\n\n\n \n \n\n。\n我们又有一个性质：\n令 \nh(x)=\\frac{x\\times(x+1)}{2}\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\n\n \n \n \n \n \n \n \n\n \n\n\n\n，则有\n\n\\begin{aligned}\nh(x+1)-h(x)&amp;=\\frac{(x+1)\\times(x+2)}{2}-\\frac{x\\times(x+1)}{2}\\\\\n&amp;=x+1\n\\end{aligned}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\n \n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n \n\n\n \n\n\n\n\n \n \n \n \n \n \n \n\n \n\n\n\n\n \n \n \n \n\n\n\n\n\n于是\n\n\\sum_{l=1}^{r+1}{g(l,r+1)}=\\sum_{l=1}^{r}{g(l,r)}+\\sum_{l=last_{r+1}+1}^{r+1}{f(l,r+1)}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n \n \n \n\n\n \n \n \n \n \n \n \n \n\n \n\n \n\n \n \n \n\n \n\n\n \n \n \n \n \n \n\n \n\n \n\n \n \n \n \n \n\n \n\n \n \n \n\n\n \n \n\n\n \n \n \n\n\n\n \n \n \n \n \n \n \n \n\n\n\n这可以用线段树的区间查找操作解决。\n开始时构造 \nlast\n\n\n\n\n\n\n\n \n \n \n \n\n 数组 \n\\Theta (n \\log{n})\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n \n \n\n，线段树 \n\\Theta (n \\log{n})\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n \n \n\n，总时间复杂度 \n\\Theta (n \\log{n})\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n \n \n \n\n \n \n\n。\n代码：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#define IL inlinetypedef long long ll;const int N = 1e6 + 5;const ll MOD = 1e9 + 7;ll a[N];int last[N];std::map&lt;ll, int&gt; map;int n;IL void init() &#123; // 输入和构造 last 数组\tstd::cin &gt;&gt; n;\tfor (int i = 1; i &lt;= n; ++i) &#123;\t\tstd::cin &gt;&gt; a[i];\t\tlast[i] = map[a[i]];\t\tmap[a[i]] = i;\t&#125;&#125;ll tree[N &lt;&lt; 2], tag[N &lt;&lt; 2];#define ls X &lt;&lt; 1, L, mid#define rs X &lt;&lt; 1 | 1, mid + 1, RIL void pushdown(int X, int L, int R) &#123;\tint mid = (L + R) &gt;&gt; 1;\ttree[X &lt;&lt; 1] += tag[X] * ll(mid - L + 1) % MOD, tag[X &lt;&lt; 1] += tag[X];\ttree[X &lt;&lt; 1 | 1] += tag[X] * ll(R - mid) % MOD, tag[X &lt;&lt; 1 | 1] += tag[X];\ttag[X] = 0;&#125;IL void pushup(int X, int L, int R) &#123;\ttree[X] = (tree[X &lt;&lt; 1] + tree[X &lt;&lt; 1 | 1]) % MOD;&#125;void insert(int X, int L, int R, int l, int r, ll add) &#123;\tif (l &lt;= L &amp;&amp; R &lt;= r) tree[X] += add * ll(R - L + 1) % MOD, tag[X] += add;\telse &#123;\t\tpushdown(X, L, R);\t\tint mid = (L + R) &gt;&gt; 1;\t\tif (mid &gt;= l) insert(ls, l, r, add);\t\tif (mid &lt; r) insert(rs, l, r, add);\t\tpushup(X, L, R);\t&#125;&#125;ll query(int X, int L, int R, int l, int r) &#123;\tif (l &lt;= L &amp;&amp; R &lt;= r) return tree[X];\telse &#123;\t\tpushdown(X, L, R);\t\tint mid = (L + R) &gt;&gt; 1;\t\tll ans = 0;\t\tif (mid &gt;= l) ans = (ans + query(ls, l, r)) % MOD;\t\tif (mid &lt; r) ans = (ans + query(rs, l, r)) % MOD;\t\treturn ans;\t&#125;&#125;IL void work() &#123;\tll sum_f = 0, g = 0, sum_g = 0;\tfor (int i = 1; i &lt;= n; ++i) &#123;\t\tinsert(1, 1, n, last[i] + 1, i, 1);\t\tsum_f = (sum_f + tree[1]) % MOD;\t\tg = (g + query(1, 1, n, last[i] + 1, i)) % MOD;\t\tsum_g = (sum_g + g) % MOD;\t&#125;\tstd::cout &lt;&lt; (MOD - sum_f + sum_g + sum_g) % MOD;&#125;int main() &#123;\tstd::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);\t\tinit();\twork();\treturn 0;&#125;\n","plink":"https://oi.reqwey.me/solution-luogu-6477/"},{"title":"【Solution】小凸玩矩阵-二分图+二分答案","date":"2021-12-11T00:00:00.000Z","date_formatted":{"ll":"Dec 11, 2021","L":"12/11/2021","MM-DD":"12-11"},"updated":"2024-01-28T08:21:50.966Z","content":"\nStop learning useless algorithms.\nGo and solve some problems.\nLearn how to use binary search.\n\n原题传送门\n\nAnalysis\n常用技巧，把一行或一列转换为点，然后原先的点转换成这个二分图的边。\n然后考虑选出第 \nk\n\n\n\n\n \n\n 大的数的最小值，这个比较难以处理。那我们考虑二分这个最小值，并判断是否合理。\n怎么判断呢？\n我一开始是将 \nval \\geq mid\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 的边加入来跑二分图的最大匹配。但这个方法有一个严重的问题。就是这个边权最小值 \n(mid)\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n --最大匹配数 \n(cnt)\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 的函数关系并非单增。有可能有多个边权最小值都是这种最大匹配数（函数是离散的），而如果采用这种二分方式则会找到 \ncnt\n\n\n\n\n\n\n \n \n \n\n 与 \ncnt+1\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 分界线上的那个 \nmid\n\n\n\n\n\n\n \n \n \n\n ，这并不是我们想要的。我们想要 \ncnt-1\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 与 \ncnt\n\n\n\n\n\n\n \n \n \n\n 分界线上的那个才是答案。\n因此我们需要转换一下思路，将 \nval \\leq mid\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 的边加入，将 \ncnt\n\n\n\n\n\n\n \n \n \n\n 与 \nn-k+1\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 进行比较。\nCode\n读入与建图12345678910111213const int N = 260;ll g[N][N], limit;int vis[N], id, match[N];int n, m, k;IL void init() &#123;  fr&lt;int&gt;(n), fr&lt;int&gt;(m), fr&lt;int&gt;(k);  for (int i = 1; i &lt;= n; ++i)    for (int j = 1; j &lt;= m; ++j)      fr&lt;ll&gt;(g[i][j]), limit = cmax&lt;ll&gt;(limit, g[i][j]);&#125;\n二分答案1234567891011IL ll binary() &#123;  ll l = 1, r = limit, mid;  while (l &lt; r) &#123;    mid = (l + r) &gt;&gt; 1;    if (check(mid) &gt;= n - k + 1)      r = mid;    else      l = mid + 1;  &#125;  return l;&#125;\nCheck12345678IL int check(ll st) &#123;  memclear(match, 0), memclear(vis, 0);  int cnt = 0;  id = 1;\t// 避免重复清空 vis 数组  for (int i = 1; i &lt;= n; ++i, ++id)    cnt += dfs(i, st);  return cnt;&#125;\n匈牙利12345678910IL bool dfs(int x, ll st) &#123;  for (int y = 1; y &lt;= m; ++y)    if (g[x][y] &lt;= st &amp;&amp; vis[y] != id) &#123;\t\t\t\t// 避免重复清空 vis 数组      vis[y] = id;      if (!match[y] || dfs(match[y], st))        return match[y] = x, true;    &#125;  return false;&#125;","plink":"https://oi.reqwey.me/solution-luogu-4251/"},{"title":"【Algorithm Notes】Convex Hull Trick","date":"2021-12-03T00:00:00.000Z","date_formatted":{"ll":"Dec 3, 2021","L":"12/03/2021","MM-DD":"12-03"},"updated":"2024-01-28T08:21:50.962Z","content":"Intro\n单调队列优化 DP 需要状态变量 \nj\n\n\n\n\n \n\n 与决策变量 \nk\n\n\n\n\n \n\n 分离，而遇到交叉项如 \ni\\times j\n\n\n\n\n\n\n \n \n \n\n 时则无能为力。因此我们需要新的方法。\n\nExample\n【例题】玩具装箱\n题目传送门。\n\n\\begin{align}\nS_i&amp;=\\sum_{j\\leq i}{C_i}+i\\\\\nf_{i, j}&amp;=\\min(f_{i - 1, k} + (S_j - S_k - L - 1)^2)\\\\\nf_{i, j}&amp;=f_{i - 1,k} + (S_j - S_k - L-1)^2\\\\\nf_j&amp;=f_k+S_j^2-2S_j(S_k+L+1)+(S_k+L+1)^2\\\\\nf_k+(S_k+L+1)^2&amp;=2S_j\\cdot S_k+(f_j+2(L+1)S_j-S_j^2)\n\\end{align}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n\n \n\n \n \n \n\n\n\n \n\n \n \n \n\n\n\n \n \n\n\n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n\n\n\n\n \n\n \n\n \n \n \n\n\n\n \n \n\n \n \n\n\n \n\n \n \n \n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n \n \n\n \n\n \n \n\n \n \n \n \n\n \n \n\n \n\n\n \n\n \n\n \n \n \n \n \n\n\n \n \n\n \n \n\n \n\n \n \n\n \n \n \n \n\n \n \n\n\n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n\n \n\n \n \n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n\n\n \n \n\n \n \n\n \n\n \n \n\n \n \n\n \n \n\n \n \n \n \n \n \n \n\n \n \n\n \n\n \n \n \n\n \n\n\n\n\n\n这里为了打消平方项的影响，我们直接把 \n(S_k+L+1)^2\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n \n \n \n\n \n \n\n\n 设置成了 \ny\n\n\n\n\n \n\n 轴。\n\n这根直线与凸壳相交，当且仅当这个点的下方的那条凸壳上的线段的斜率 \n&lt; k\n\n\n\n\n\n \n \n\n ，而上方这条 \n \\geq k\n\n\n\n\n\n \n \n\n。\n方法\n如果 \nx_i\n\n\n\n\n\n \n \n\n 从小到大依次进来：此时只需维护半个凸壳。\n\n将所给直线与凸壳上的点从左端开始进行对比，找到斜率介于两者之间的位置取出该位置的值作为 j\n按照原始方程进行转移\n维护凸壳，删除多余的点，将点 \n(x_i, y_i)\n\n\n\n\n\n\n\n\n\n \n\n \n \n\n \n\n \n \n\n \n\n 从右端加入凸壳\n\n需要注意的是，有时候按顺序插入的点不一定在凸壳的右侧，这时候需要维护整个凸壳，并多一个 \n\\log\n\n\n\n\n\n\n \n \n \n\n 来二分查找点的位置。\nCode\nInit12345IL void init() &#123;\trd&lt;int&gt;(n), rd&lt;ll&gt;(L);\tfor (int i = 1; i &lt;= n; c[i] += c[i - 1] + 1, ++i) rd&lt;ll&gt;(c[i]);\tfor (int i = 1; i &lt;= n; ++i) Debug(&quot;%d\\n&quot;, c[i]);&#125;\nDP1234567891011121314151617181920IL Lf slope(int u, int v) &#123;\tLf x_u = X(u), x_v = X(v), y_u = Y(u), y_v = Y(v);\tif (x_u == x_v) return 1e18;\treturn (y_v - y_u) / (x_v - x_u);&#125;IL void work() &#123;\tint l = 1, r = 0;\tq[++r] = 0;\tfor (int j = 1; j &lt;= n; ++j) &#123;\t\twhile (l &lt; r &amp;&amp; slope(q[l], q[l + 1]) &lt;= c[j] * 2.0)\t\t\t++l;\t\tf[j] = f[q[l]] + (c[j] - b(q[l])) * (c[j] - b(q[l]));\t\tDebug(&quot;dp[%d] is %d while using %d\\n&quot;, j, f[j], l);\t\twhile (l &lt; r &amp;&amp; slope(q[r - 1], q[r]) &gt;= slope(q[r - 1], j))\t\t\t--r;\t\tq[++r] = j;\t&#125;\tprintf(&quot;%lld\\n&quot;, f[n]);&#125;\n","plink":"https://oi.reqwey.me/algorithm-slope/"},{"title":"【Solution】Muddy Fields G-二分图匹配","date":"2021-10-18T21:28:00.000Z","date_formatted":{"ll":"Oct 18, 2021","L":"10/18/2021","MM-DD":"10-18"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n建模\n\n二分图匹配的模型有两个要素：\n\n\n节点能分成独立的两个集合，每个集合内部有 \n0\n\n\n\n\n \n\n 条边：\n0\n\n\n\n\n \n\n 要素\n\n\n每个节点只能与 \n1\n\n\n\n\n \n\n 条匹配边相连：\n1\n\n\n\n\n \n\n 要素\n——摘自李煜东《算法竞赛进阶指南》\n\n\n\n\n分析一下这道题的两个要素：\n\n每条横向木板之间互不交叉，每条纵向木板之间互不交叉：\n0\n\n\n\n\n \n\n 要素\n每个泥地仅能被 \n1\n\n\n\n\n \n\n 条最优横向木板和 \n1\n\n\n\n\n \n\n 条最优纵向木板包含：\n1\n\n\n\n\n \n\n 要素\n\n那我们可以以每个泥地为边，以包含其的最优横向木板和最优纵向木板为其左右端点，建立二分图。\n题目要求最少木板数覆盖全部的泥地，这可以转化成一次操作可以选择一个点，将所连的边染色，目的是让所有边被染色，然后求最少需要的点数，即为二分图最小点覆盖。\n而最小点覆盖等于最大匹配，二分图最大匹配的König定理及其证明 | Matrix67: The Aha Moments，故建图跑匈牙利即可。\n匈牙利算法\n每次找到一条未匹配-匹配-未匹配-\n\\cdots\n\n\n\n\n \n\n-未匹配的路径，将其取反，得到总匹配数 \n+1\n\n\n\n\n\n \n \n\n。\n这条路径被称为增广路。\n好了相信你（我）已经学会匈牙利算法了。\n代码\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;const int N = 55;bool map[N][N], g[N * N][N * N], vis[N * N];int r[N][N], c[N][N], match[N * N];int crow, ccol;bool dfs(int x) &#123;\tfor (int y = 1; y &lt;= ccol; ++y)\t\tif (g[x][y] &amp;&amp; !vis[y]) &#123;\t\t\tvis[y] = true;\t\t\tif (!match[y] || dfs(match[y])) return match[y] = x, true;\t\t&#125;\treturn false;&#125;int main() &#123;#ifdef ONLINE_JUDGE#endif#ifdef LOCAL\tclock_t c1 = clock();\tfreopen(&quot;in&quot;, &quot;r&quot;, stdin);\tfreopen(&quot;out&quot;, &quot;w&quot;, stdout);#endif\tint n, m;\tchar cc;\tscanf(&quot;%d%d&quot;, &amp;n, &amp;m);\tfor (int i = 1; i &lt;= n; ++i)\t\tfor (int j = 1; j &lt;= m; ++j) &#123;\t\t\tstd::cin &gt;&gt; cc;\t\t\tif (cc == &#x27;*&#x27;) &#123;\t\t\t\tmap[i][j] = true;\t\t\t\tif (j == 1 || !map[i][j - 1]) ++crow;\t\t\t\tr[i][j] = crow;\t\t\t&#125;\t\t&#125;\tfor (int j = 1; j &lt;= m; ++j) &#123;\t\tfor (int i = 1; i &lt;= n; ++i)\t\t\tif (map[i][j]) &#123;\t\t\t\tif (i == 1 || !map[i - 1][j]) ++ccol;\t\t\t\tc[i][j] = ccol;\t\t\t\tg[r[i][j]][c[i][j]] = true;\t\t\t&#125;\t&#125;\tint ans = 0;\tfor (int i = 1; i &lt;= crow; ++i) &#123;\t\tmemset(vis, 0, sizeof vis);\t\tans += int(dfs(i));\t&#125;\tprintf(&quot;%d&quot;, ans);#ifdef LOCAL\t// 当运行暴力对拍时，请注释掉下面这行\tprintf(&quot;\\nTime used: %ldms.\\n&quot;, clock() - c1);#endif\treturn 0;&#125;\n","plink":"https://oi.reqwey.me/solution-luogu-6062/"},{"title":"【Algorithm Notes】并查集按秩合并","date":"2021-08-10T00:00:00.000Z","date_formatted":{"ll":"Aug 10, 2021","L":"08/10/2021","MM-DD":"08-10"},"updated":"2024-01-28T08:21:50.962Z","content":"我们都知道，并查集的路径压缩大大加速了操作的时间复杂度，但是如果出题人足够毒瘤，仍然可以把你卡掉。\n\n比如说你在1号点上连了2、3、4、5, 这时候进来个6，您觉得应该将1连到6上更优呢？还是反过来更优呢？\n基于减少复杂度的贪心思想，我们当然希望能够把一棵较小的并查集并入较大的一棵当中。\n那我们就多维护一个siz[root]，表示当前这棵以root为根的并查集的大小或深度。\n这样，我们以siz作为关键字进行判断谁应该合并到谁的父亲上。\n更进一步\n\n开两个数组好累啊 QwQ\n那好，我们可以只开一个！\n\n通过观察，我们发现这棵并查集，它的根节点的父亲fa[root]是没有用的，他唯一的功能是判断到头了没有。\n那我们可以令fa[root] = siz[root]。\n当然，也许会问，如果是这样会不会造成无法判断根，数组越界？\n说的好！\n那我们可以把他改成这样：fa[root] = -siz[root]。\n一旦发现fa[x] &lt; 0，就立刻发现不对劲！节点编号不可能是负数！那一定是到头啦，于是我们愉快的把x揪了出来，他就是根节点！\n看起来细节还蛮多的嘛！\n可不是嘛！代码写起来细节更多！尤其是如果写成非递归的形式，那么你可能要提前判一下fa[fa[x]]是否是负数！小心跳过头了哦！\n实战！\n\n以子树大小为关键字\n在 main() 中\n12345678910111213141516171819read(n), read(m);for (int i = 1; i &lt;= n; i++) fa[i] = -1;for (int i = 1; i &lt;= m; i++) &#123;\tint z, x, y;\tread(z), read(x), read(y);\tif (z == 1) &#123;\t\tint fx = f(x), fy = f(y);\t\tif (fx != fy) &#123;\t\t\tif (fa[fx] &lt; fa[fy])\t\t\t\tfa[fx] += fa[fy], fa[fy] = fx;\t\t\telse &#123;\t\t\t\tfa[fy] += fa[fx], fa[fx] = fy;\t\t\t&#125;\t\t&#125;\t&#125; else &#123;\t\tint fx = f(x), fy = f(y);\t\tputs(fx == fy ? &quot;Y&quot; : &quot;N&quot;);\t&#125;&#125;\nf() 函数\n1234567const int N = 1e4 + 5;int fa[N];IL int f(int x) &#123;    while (fa[x] &gt; 0 &amp;&amp; fa[fa[x]] &gt; 0) x = fa[x] = fa[fa[x]];    return fa[x] &lt; 0 ? x : fa[x];&#125;\n以深度为关键字\n在 main() 中\n123456789101112131415161718192021read(n), read(m);for (int i = 1; i &lt;= n; i++) fa[i] = -1;for (int i = 1; i &lt;= m; i++) &#123;\tint z, x, y;\tread(z), read(x), read(y);\tif (z == 1) &#123;\t\tint fx = f(x), fy = f(y);\t\tif (fx != fy) &#123;\t\t\tif (fa[fx] &lt; fa[fy])\t\t\t\tfa[fy] = fx;\t\t\telse &#123;\t\t\t\tif (fa[fx] == fa[fy])\t\t\t\t\tfa[fy]--;\t\t\t\tfa[fx] = fy;\t\t\t&#125;\t\t&#125;\t&#125; else &#123;\t\tint fx = f(x), fy = f(y);\t\tputs(fx == fy ? &quot;Y&quot; : &quot;N&quot;);\t&#125;&#125;\nf()函数\n\n与第一种情况的相同\n\n","plink":"https://oi.reqwey.me/algorithm-merge-by-rank/"},{"title":"【Solution】砝码称重-DP+bitset","date":"2021-07-31T00:00:00.000Z","date_formatted":{"ll":"Jul 31, 2021","L":"07/31/2021","MM-DD":"07-31"},"updated":"2024-01-28T08:21:50.966Z","content":"原题传送门\n\n思路\n题目要求从 \nn\n\n\n\n\n \n\n 个砝码里面去掉 \nm\n\n\n\n\n \n\n 个，那很自然的朴素想法是一个DFS跑过去，然后筛选出一种合法的方案，再套一个01背包统计一下答案即可\n然后分析一下复杂度，达到了\n\nT(n) = 2^n  \\times (n \\sum{a_i} + 3n) \\rightarrow \\Theta(2^n \\cdot n \\sum{a_i})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n \n \n\n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n\n \n \n\n \n\n\n其中第一项是枚举子集的复杂度，之后是01背包方案数 + 扫一遍 + 清零 + 求出背包容量t的复杂度。\n\n这里参考了 @皎月半洒花 的题解\n\n然后这会 \n\\texttt{T}\n\n\n\n\n \n\n 掉。\n想着怎么优化。\n优化 DFS\n把前面提到的筛选合法的方案看成一个01串，去掉的用 0，留下来的用 1，然后直接 for 循环枚举，这样可以卡掉 DFS 递归的常数。\n这里的循环从 \n2^{n - m - 1}\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n 开始（因为小于 \nn - m\n\n\n\n\n\n\n \n \n \n\n 个位数根本没有 \nn - m\n\n\n\n\n\n\n \n \n \n\n 个 \n1\n\n\n\n\n \n\n），到\n2^n - 1\n\n\n\n\n\n\n\n \n \n \n \n\n结束。\n然后判断合法性要用到 popcount() 函数，即统计一个数二进制表示下 1 的个数。\n这个函数是 gcc 的内置函数，函数名为 __builtin_popcount()。但CCF禁止使用下划线开头的函数，所以我们自己编一个。\n这里我看到了一个效率很高的版本，是在 @pantw 的题解 中展示的。他不用一个一个枚举位数，而是通过 分块 + 打表 的方式，每 \n4\n\n\n\n\n \n\n 位为一组进行统计。\n1234567const int tb[16] = &#123;0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4&#125;;IL int popcnt(ll x) &#123;\tint cnt = 0;\tfor (; x; x &gt;&gt;= 4) cnt += tb[x &amp; 15];\treturn cnt;&#125;\n其中 tb 数组存的是 \n0 \\sim 15\n\n\n\n\n\n\n\n \n \n\n \n \n\n\n 二进制位上 \n1\n\n\n\n\n \n\n 的个数。\n优化 01背包\n嗯，先说说正常的 01背包 该怎么写。\n\n这里参考了 @hsfzLZH1 的题解。\n\n12345678910111213memset(f, 0, sizeof f);f[0] = true;ans = 0;tot = 0;\t\t\t\t\t // 清零，因为可能要调用多次for (int i = 0; i &lt; n; i++)\t // 从前到后选取所有的砝码&#123;\tif (tf[i]) continue;  // 如果被标记为已经舍弃就跳过\tfor (int j = tot; j &gt;= 0; j--)\t\tif (f[j] &amp;&amp; !f[j + a[i]])\t\t\tf[j + a[i]] = true, ans++;\t// 否则dp并且维护ans的值\ttot += a[i];  // 这个tot意为当前f[i]为真值的最大的i，极大加快了dp过程&#125;ret = max(ans, ret);  // 更新最后的答案\n然后咱们想，能不能也用 01串 表示 DP状态 呢？\n于是咱们产生了想法。。。\n\n这里参考了 @皎月半洒花 的题解\n\n12345678bitset&lt;2021&gt; dp;dp.reset(), dp[0] = 1, t = 0 ; for (j = 0 ; j &lt; N ; ++ j) t += (1 &lt;&lt; j &amp; i) ? base[j + 1] : 0 ;for (k = 0 ; k &lt; N ; ++ k)     for (j = t ; j &gt;= base[k + 1] ; -- j)        dp[j] = (1 &lt;&lt; k &amp; i) ? dp[j] : (dp[j] | dp[j - base[k + 1]]) ; Ans = max(Ans, (int)dp.count() - 1) ;\n哦，对了， 这个最终的 \n-1\n\n\n\n\n\n \n \n\n 是把称出了 \n0\n\n\n\n\n \n\n 的重量扣掉。\n\n还不够？\n确实。\n\n你看这个 DP 是怎么转移的。由于 dp 是一个 bitset，在里层的 for 循环以后，从动态上看，这个bitset 所有的 1 都被移动了 base[k + 1] 位（注：这位老哥从 1 开始读入）。\n因此，我们实际上是可以用位运算压掉这一维！！！\n我们写出了如下代码：\n\n这里参考了 @pantw 的题解\n\n12345bitset&lt;2021&gt; S(1);for (int j = 0; j &lt; n; j++)    if (i &amp; (1 &lt;&lt; j)) S |= S &lt;&lt; a[j];int siz = S.count();ans = max(ans, siz);\n于是我们愉快的通过了这道题。。。\n完整代码\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;typedef long long ll;#define IL inlinetemplate &lt;class I&gt;IL void read(I &amp;x) &#123;\tint fl = 1;\tx = 0;\tchar c = getchar();\twhile (!isdigit(c)) &#123;\t\tif (c == &#x27;-&#x27;) fl = -1;\t\tc = getchar();\t&#125;\twhile (isdigit(c)) x = x * 10 + c - &#x27;0&#x27;, c = getchar();\tx *= fl;&#125;int a[100];const int tb[16] = &#123;0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4&#125;;IL int popcnt(ll x) &#123;\tint cnt = 0;\tfor (; x; x &gt;&gt;= 4) cnt += tb[x &amp; 15];\treturn cnt;&#125;int main() &#123;#ifdef LOCAL\tclock_t c1 = clock();\tfreopen(&quot;in.in&quot;, &quot;r&quot;, stdin);\tfreopen(&quot;out.out&quot;, &quot;w&quot;, stdout);#endif#ifdef ONLINE_JUDGE#endif\tint n, m, d, ans = 0;\tread(n), read(m), d = n - m;\tfor (int i = 0; i &lt; n; i++) read(a[i]);\tfor (int i = 1 &lt;&lt; (d - 1), ln = 1 &lt;&lt; n; i &lt; ln; i++)\t\tif (popcnt(i) == d) &#123;\t\t\tbitset&lt;2021&gt; S(1);\t\t\tfor (int j = 0; j &lt; n; j++)\t\t\t\tif (i &amp; (1 &lt;&lt; j)) S |= S &lt;&lt; a[j];\t\t\tint siz = S.count();\t\t\tans = max(ans, siz);\t\t&#125;\tprintf(&quot;%d\\n&quot;, ans - 1);#ifdef LOCAL\tcout &lt;&lt; &quot;\\nTime used: &quot; &lt;&lt; clock() - c1 &lt;&lt; &quot;ms&quot; &lt;&lt; endl;#endif\treturn 0;&#125;","plink":"https://oi.reqwey.me/solution-luogu-1441/"},{"title":"【Solution】[NOIP2017 提高组] 宝藏-状压DP","date":"2021-07-31T00:00:00.000Z","date_formatted":{"ll":"Jul 31, 2021","L":"07/31/2021","MM-DD":"07-31"},"updated":"2024-01-28T08:21:50.966Z","content":"原题传送门\n\n理论\n以每个点为转移显然不行。因为贡献和之前的长度有关。\n因此考虑集合之间的转移。设从节点 \nj\n\n\n\n\n \n\n 出发开始挖要转移到集合 \nS(j \\notin S)\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n，他到起点的距离为 \ni\n\n\n\n\n \n\n ， 设他从集合 \nS_2\n\n\n\n\n\n \n \n\n 转移过来，则可写出这样的方程：\n\nf(i,j,S)=\\underset{j\\in S_2\\in S}{\\min}(f(i,j,S-S_2)+(i+1)\\times g(j,k)+f(i+1,k,S2-\\{k\\}))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n\n \n \n \n\n\n \n \n\n \n \n\n \n \n\n\n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n实践\n1234567891011121314151617181920212223242526272829303132typedef long long ll;const int N = 13, INF = 0x3f3f3f3f;memset(f, 0x3f, sizeof f);memset(g, 0x3f, sizeof g);IL void prework() &#123;\tfor (int i = 1; i &lt; up; ++i) siz[i] = siz[i &amp; (i - 1)] + 1;                    // 为了剪枝。i &amp; i-1 会导致 lowbit 那一位消失\tfor (int i = 0; i &lt; n; ++i) lowbit[1 &lt;&lt; i] = i;\tfor (int i = 1; i &lt; up; ++i) lowbit[i] = lowbit[i &amp; -i];&#125;IL void work() &#123;\tfor (int i = 0; i &lt; n; ++i) f[n - 1][i][0] = 0; // 初值处理1\tfor (int i = n - 2; ~i; --i) // 倒序\t\tfor (int j = 0; j &lt; n; ++j) &#123;\t\t\tf[i][j][0] = 0; // 初值处理2\t\t\tfor (int S = 0; S &lt; up; ++S) if (!((1 &lt;&lt; j) &amp; S) &amp;&amp; siz[S] &lt;= n - i - 1) &#123;\t\t\t// 剪枝1。首先满足 j 不属于 S，然后由于距离肯定由点连成，所以siz要符合实际意义\t\t\t\tfor (int S2 = S; S2; S2 = S &amp; (S2 - 1)) if (f[i][j][S] &gt; f[i][j][S &amp; ~S2]) &#123;\t\t\t\t// 剪枝2。必要时才转移\t\t\t\t\tint tmp = S2;\t\t\t\t\tfor (int k = lowbit[tmp]; tmp; k = lowbit[tmp &amp;= ~(1 &lt;&lt; k)]) if (g[j][k] &lt; INF) &#123;\t\t\t\t\t\tcmin(f[i][j][S],\t\t\t\t\t\t\tf[i][j][S &amp; ~S2] + f[i + 1][k][S2 &amp; ~(1 &lt;&lt; k)] + (i + 1) * g[j][k]);\t\t\t\t\t&#125;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;&#125;\n","plink":"https://oi.reqwey.me/solution-luogu-3959/"},{"title":"【Algorithm Notes】线段树的一些技巧","date":"2020-11-07T00:00:00.000Z","date_formatted":{"ll":"Nov 7, 2020","L":"11/07/2020","MM-DD":"11-07"},"updated":"2024-01-28T08:21:50.966Z","content":"\n线段树, OI中最为常用的一种数据结构之一, 特点是结构美丽, 性质特殊, 可以用来解决很多看似不相干的问题。\n\n\n标记的处理\n通常情况下, 线段树获取一个区间的信息需要\n\\Theta{(\\log n)}\n\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n \n \n\n \n \n\n\n的时间复杂度, 但是在经历多次访问后, 我们可以通过记录每次访问的一些信息来优化后续的访问速度, 避免重复的行为\n这种处理方式就是打标记, 它通常有两种方式\n懒标记\n懒标记\n\\texttt{(lazy tag)}\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n顾名思义, 就是当你访问的线段树节点区间正好包含在需要更新的区间之内时, 就不需要再往下访问了, 之间给这个节点打一个tag, 告诉他我给你这个区间的所有内容都操作了一下, 这样, 当你下次询问的时候, 之间把这个tag供上去就行了\n但这样就会出现一个性质: 即靠上边的节点的信息永远比靠下的节点要新, 因此当你询问到一个区间, 它的父亲节点没有把最新的状态传下来, 你拿着的还是&quot;过时的&quot;状态, 那么询问就会出现异常, 因此我们只好在发现这个节点有lazy tag时十分不情愿地把它的tag挪到下一层(仅此而已!!!)此情此景, 有没有想起当你赖床的时候你妈妈催你起床, 而你经过顽强的抵抗只能一步一步地挪起来?(笑)确实可以有这种情况, 就是每次询问到下一层, 懒标记就要先逃到再下一层, 甚至要逃到叶子节点才能停下来, 这样, 懒标记就丧失了它懒的用途, 仍会拖慢我们的时间复杂度\n标记永久化\n这是一种比懒标记更懒的标记!\n它直接赖在节点上不动了!!!\n标记永久化是一种比较神奇的技巧, 它的 update 操作和上面那位一样的, 不同的在于它的标记不会移动, 永远固定在那个节点上\n在 query 时, 多维护一个 add值, 从上到下一点一点把这条链上的 tag 串起来\n这样就会有一个新的性质: 即在q到一个节点时同时累计起来的add值就是该节点最新的标记情况, 因此返回的信息就变为\nval[p] + add \\times (r - l + 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n\n但这样做具有较大的局限性: 由于它改变了更新的先后顺序, 所以只能适用于区间加, 区间乘, 区间异或等等可以满足交换律的操作\n代码这里就不放了, 网上随便找都有\nps 这个技巧是我在看一篇题解时才学到的, 他这里的 update 操作似乎没有一点 pushdown 的影子, 然后它没有 \n\\texttt{query}\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 操作, 直接把 \ntree[1]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 拿去更新答案了. 其实这就利用了标记永久化的性质, 因为到第一个节点时 \n\\texttt{add}\n\n\n\n\n\n \n \n \n\n 的值是 \n0\n\n\n\n\n \n\n 啊, 所以 \ntree[1]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 永远是最新的!\n\n讲完了代码的技巧, 现在我们来讲线段树的一些应用\n\n线段树&amp;扫描线\n遇到求一些会有重叠的矩形的面积并(或周长并)时, 我们应该想到线段树＋扫描线\n这里推荐阅读学习笔记-扫描线这篇文章\n总结 这里的细节真的是亿点点多, 看的蒟蒻我惊慌失措.\n其中有一个要注意的点是原文中没有讲的, 就是它的代码里用的标记永久化思想, 我在上面也写了.\n还有一些重要的点, 原文中也有写, 这里在重申一下\n\n由于他习惯从下往上扫(我习惯性理解的扫描线都是从左往右的, 不过这不是重点), 又由于题目给的坐标相差很大(取值范围 \n0\\leq x_1&lt;x_2\\leq10^9,0\\leq y_1&lt;y_2\\leq10^9\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n \n\n \n \n\n \n\n \n \n\n \n\n \n \n \n\n\n ) 因此我们考虑把 \nx\n\n\n\n\n \n\n 坐标进行离散化, 变成线段树的下标\n如何用一个线段树上的一段区间表示一小条线段? 答案是一段区间\n[l, r]\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n表示 \n[X[l], X[r + 1])\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n 每段包括左端点, 但不包括右端点, 避免重复计数\n\n线段树&amp;树链剖分\n遇到一些一次性修改一条树链(或子树) 的题, 我们通常是把它剖分了\n然后利用\n\\texttt{dfn}\n\n\n\n\n\n\n \n \n \n\n 序的连续性, 将链上(子树)修改转变为线段树区间修改\n其中修改树链时要做个求\n\\texttt{LCA}\n\n\n\n\n\n\n \n \n \n\n的操作, 而修改子树时不用, 但是要用到子树的大小这个信息\n李超线段树\n题目传送门\n\n留坑待填\n\n","plink":"https://oi.reqwey.me/segment-tree-tricks/"},{"title":"【Algorithm Notes】数学","date":"2020-08-30T22:24:00.000Z","date_formatted":{"ll":"Aug 30, 2020","L":"08/30/2020","MM-DD":"08-30"},"updated":"2024-01-28T08:21:50.966Z","content":"整理成了 PPT 形式，链接。\n","plink":"https://oi.reqwey.me/math/"},{"title":"【Solution】[NOI Online #1 入门组] 文具订购-DP","date":"2020-03-08T00:00:00.000Z","date_formatted":{"ll":"Mar 8, 2020","L":"03/08/2020","MM-DD":"03-08"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n\n分类讨论\n可以枚举三个数中最小的\n下面以 \na\n\n\n\n\n \n\n 最小的情况为例\n\n\n\\because 7a+4b+3c=n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\n\\therefore 7a=n-4b-3c\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n\n\n由于我们要考虑 \na+b+c\n\n\n\n\n\n\n\n \n \n \n \n \n\n 最大. 因为 \nb\n\n\n\n\n \n\n 的系数比 \nc\n\n\n\n\n \n\n 要大, 而和为定值, 所以当 \na\n\n\n\n\n \n\n 固定时, \nb\n\n\n\n\n \n\n 越小越好\n所以我们就可以令 \nb\n\n\n\n\n \n\n 为 \na, a+1, a+2\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n\n 中的一个(为了满足 \nc\n\n\n\n\n \n\n 是整数, 找一个值使得 \nn-4b-7a \\equiv 0 \\pmod {3}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n\n \n \n \n\n \n \n\n)\n\n将上面的方法重复套到 \nb\n\n\n\n\n \n\n 和 \nc\n\n\n\n\n \n\n 中, 跑三遍 for (有点丑)即可\n最后然后别忘了校验得出来的值是否合理\nCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;iostream&gt;#define min3(a, b, c) std::min(std::min(a, b), c)const int coeff_a = 7, coeff_b = 4, coeff_c = 3;int main()&#123;    int n;    int ans_a = -1, ans_b = -1, ans_c = -1;    scanf(&quot;%d&quot;, &amp;n);        for (int a = 0; a &lt;= n; a++) // a &lt;= b, c    &#123;        int b = a, c;            while (((n - a * coeff_a - b * coeff_b) % coeff_c + coeff_c) % coeff_c != 0)            b++;        c = (n - a * coeff_a - b * coeff_b) / coeff_c;            if (c &lt; 0 || c &lt; a)            break; // 矛盾            if (min3(ans_a, ans_b, ans_c) &lt; a)            ans_a = a, ans_b = b, ans_c = c;        else if (min3(ans_a, ans_b, ans_c) == a &amp;&amp; ans_a + ans_b + ans_c &lt; a + b + c)            ans_a = a, ans_b = b, ans_c = c;    &#125;        for (int b = 0; b &lt;= n; b++) // b &lt;= a, c    &#123;        int a = b, c;            while (((n - a * coeff_a - b * coeff_b) % coeff_c + coeff_c) % coeff_c != 0)            a++;        c = (n - a * coeff_a - b * coeff_b) / coeff_c;            if (c &lt; 0 || c &lt; b)            break; // 矛盾            if (min3(ans_a, ans_b, ans_c) &lt; b)            ans_a = a, ans_b = b, ans_c = c;        else if (min3(ans_a, ans_b, ans_c) == b &amp;&amp; ans_a + ans_b + ans_c &lt; a + b + c)            ans_a = a, ans_b = b, ans_c = c;    &#125;        for (int c = 0; c &lt;= n; c++) // c &lt;= a, b    &#123;        int a = c, b;            while (((n - a * coeff_a - c * coeff_c) % coeff_b + coeff_b) % coeff_b != 0)            a++;        b = (n - a * coeff_a - c * coeff_c) / coeff_b;            if (b &lt; 0 || b &lt; c)            break; // 矛盾            if (min3(ans_a, ans_b, ans_c) &lt; c)            ans_a = a, ans_b = b, ans_c = c;        else if (min3(ans_a, ans_b, ans_c) == c &amp;&amp; ans_a + ans_b + ans_c &lt; a + b + c)            ans_a = a, ans_b = b, ans_c = c;    &#125;        if (ans_a == -1)        puts(&quot;-1&quot;);    else        printf(&quot;%d %d %d&quot;, ans_a, ans_b, ans_c);    return 0;&#125;","plink":"https://oi.reqwey.me/solution-luogu-6188/"},{"title":"【Algorithm Notes】LCA Tarjan求法","date":"2020-02-06T00:00:00.000Z","date_formatted":{"ll":"Feb 6, 2020","L":"02/06/2020","MM-DD":"02-06"},"updated":"2024-01-28T08:21:50.962Z","content":"流程\n前置操作分为以下几步:\n\n使用 \n\\texttt{DFS}\n\n\n\n\n\n\n \n \n \n\n 遍历整棵树\n当一个节点被访问过时, 将其标记为1\n当一个节点及其子树(或其本身就是叶子节点)都被访问过时, 将该点标记为2\n\n\n这样, 在任意一次操作过后, 都会出现如下情况:\n所有的标记为2的节点, 共同构成一棵子树\n且该子树总是在整棵树的左下处\n从动态的角度来看, 就是一棵全为2的子树, 从左下角的那个叶子节点处缓缓地&quot;长&quot;了出来\n这样有什么好处呢\n这个性质可以帮助我们很好地离线解决\n\\texttt{LCA}\n\n\n\n\n\n\n \n \n \n\n问题\nSolve\n建立一个并查集: father[]\n在搜索的返回过程中, 将已经变成2的那个节点的father设为它的父亲节点(相当于把该节点&quot;缩&quot;到了其父亲节点上)\n在搜索的返回前, 即遍历完该节点的子树后, 判断该节点\nu\n\n\n\n\n \n\n有没有被&quot;提问&quot;过\n如果有, 假设提问为\nlca(u, v)\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n, 则标记答案为getfather(v), 其中getfather()函数为并查集自带的查找祖先节点的函数\n\n为什么?\n\n根据上边的结论, 此时的getfather(v)即为那棵全为2的子树的根节点\nroot'\n\n\n\n\n\n\n\n \n \n \n\n \n \n\n\n,  \n\\because u\n\n\n\n\n\n \n \n\n和\nv\n\n\n\n\n \n\n均在这棵子树上, \n\\therefore root'\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n\n为\nu\n\n\n\n\n \n\n和\nv\n\n\n\n\n \n\n的公共祖先\n考虑\n\\texttt{DFS}\n\n\n\n\n\n\n \n \n \n\n序, \n\\because \\texttt{DFS}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n访问完一个节点不会马上往上走, 而是会去遍历其它节点, \n\\therefore root'\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n\n以下没有一个\nroot''\n\n\n\n\n\n\n\n \n \n \n\n \n\n \n \n\n\n\n满足是\nu\n\n\n\n\n \n\n和\nv\n\n\n\n\n \n\n的公共祖先 \n\\therefore lca(u, v) = root'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n\n\n代码\nCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int SIZE = 5e6 + 1;struct edge&#123;    int to_node, id;    edge(int t, int i): to_node(t), id(i) &#123;&#125;    ~edge() = default;&#125;;vector&lt;int&gt; edges[SIZE];vector&lt;edge&gt; querys[SIZE];int father[SIZE], mark[SIZE], ans[SIZE];int n, m, s;int getfa(int x)&#123;    if (father[x] == x)        return x;    else        return father[x] = getfa(father[x]);&#125;void tarjan(int x)&#123;    mark[x] = 1;    for (auto i = edges[x].begin(); i != edges[x].end(); i++)    &#123;        if (mark[*i])            continue;        tarjan(*i);        father[*i] = x;    &#125;    for (auto i = querys[x].begin(); i != querys[x].end(); i++)    &#123;        int y = (*i).to_node, id = (*i).id;        if (mark[y] == 2)            ans[id] = getfa(y);    &#125;    mark[x] = 2;&#125;int main()&#123;    int u, v;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);    for (int i = 1; i &lt;= n; i++)    &#123;        father[i] = i;        mark[i] = 0;    &#125;    for (int i = 1; i &lt; n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        edges[u].emplace_back(v);        edges[v].emplace_back(u);    &#125;    int x, y;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        if (x == y)            ans[i] = 0;        else        &#123;            querys[x].emplace_back(edge(y, i));            querys[y].emplace_back(edge(x, i));        &#125;    &#125;    tarjan(s);    for (int i = 1; i &lt;= m; i++)        printf(&quot;%d\\n&quot;, ans[i]);    return 0;&#125;\n时间复杂度\n\n\\Theta{(n + m)}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n\n搜索过程是\n\\Theta{(n)}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n的, 而其中的求解过程可以单独拆出来看, 它就是一个\n\\Theta{(m)}\n\n\n\n\n\n\n\n \n\n \n \n \n\n\n\n用一张表来分析分析求\n\\texttt{LCA}\n\n\n\n\n\n\n \n \n \n\n的各种算法的优劣之处:\n\n\n算法\n优劣\n时间复杂度\n评测结果\n\n\n\n\n朴素\n比较好想2333\n\n\\Theta{(nm)}\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n\n\n\nTLE\n\n\n倍增优化\n也比较好想, 但是较容易敲挂\n\n\\Theta{((n + m)logn)}\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\nAC\n\n\nTarjan\n比较精妙, 也不太好写\n\n\\Theta{(n + m)}\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n\n\n\nAC\n\n\n","plink":"https://oi.reqwey.me/algorithm-lca-2/"},{"title":"【Algorithm Notes】LCA倍增求法","date":"2020-01-28T00:00:00.000Z","date_formatted":{"ll":"Jan 28, 2020","L":"01/28/2020","MM-DD":"01-28"},"updated":"2024-01-28T08:21:50.962Z","content":"定义\n一个点的祖先:从该节点出发, 一路向上走能碰到的就是其祖先了\n两个点的公共祖先: 就是同一棵树上两个节点的祖先集合中的交集\n最近公共祖先就是这个交集里面最靠下的\n\n注意到以上的表述中经常出现向上或靠下等字眼, 说明求最近公共祖先的算法肯定与求节点的高度有关\n朴素算法法求LCA\n想象一下这个过程:\n\n\n两个节点先跳到同一个高度\n\n\n如果两节点相遇 (即原先两个节点存在祖孙关系), 该点即为LCA, 退出\n\n\n否则, 一起向上跳, 直到相遇\n\n\n优化\n\n以上这种一层一层跳的方法太慢了, 面对一棵巨大的树时会跑得巨慢, 我们要尝试优化这个过程\n试想一下: 如果用倍增跳呢? 是不是速度立刻就上去了?\n\n一些前置工作\n\n用倍增的思想求出节点 \nx\n\n\n\n\n \n\n 往上跳 \n2^p\n\n\n\n\n\n \n \n\n 步后可以到达的节点, 存在 \nfa[x][p]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n 中\n用 \n\\texttt{BFS}\n\n\n\n\n\n\n \n \n \n\n 或 \n\\texttt{DFS}\n\n\n\n\n\n\n \n \n \n\n 求出节点 \nx\n\n\n\n\n \n\n 的祖先, 存在 \ndeep[x]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 中\n\n这样, 每次跳的时候, 可以通过比较 \ndeep[a]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 是否等于 \ndeep[b]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n 来判断是否在同一层, 并增加跳的长度, 把朴素算法的时间复杂度优化到 \nlog\n\n\n\n\n\n\n \n \n \n\n 级别\n具体实现\n从根节点遍历整棵树, 顺便记录一下子节点的信息\nCode123456789101112node nod = que.front(); que.pop();for (auto i = edges[nod.x].begin(); i != edges[nod.x].end(); i++)&#123;    if ((*i) != nod.fa) // 该节点不为父节点    &#123;        que.emplace(node(*i, nod.x));        deep[*i] = deep[nod.x] + 1; // 求deep[]数组        fa[*i][0] = nod.x;        for (int j = 1; (1 &lt;&lt; j) &lt;= deep[*i]; j++) // 倍增法求fa[]数组            fa[*i][j] = fa[fa[*i][j - 1]][j - 1];    &#125;&#125;\n开始愉快地跳跃\n\n\n先跳到同一高度\nCode1234567891011if (deep[a] &lt; deep[b])    swap(a, b);if (!deep[b])    return b;for (int i = MAXP; i &gt;= 0; i--)&#123;    if (deep[fa[a][i]] &gt;= deep[b])        a = fa[a][i];    if (a == b)        return a;&#125;\n\n\n两个点一起往上跳\nCode123456789for (int i = MAXP; i &gt;= 0; i--)&#123;    if (fa[a][i] != fa[b][i])    &#123;        a = fa[a][i];        b = fa[b][i];    &#125;&#125;return fa[a][0];\n\n\n上代码\nCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;struct node&#123;    int x, fa;    node(int xx = 0, int ffa = 0) : x(xx), fa(ffa) &#123;&#125;    ~node() = default;&#125;;const int SIZE = 5e6 + 1, MAXP = 20;vector&lt;int&gt; edges[SIZE];queue&lt;node&gt; que;int n, m, s;int fa[SIZE][MAXP + 1], deep[SIZE];void bfs(int st)&#123;    que.emplace(node(st, 0));    deep[st] = 0;    while (!que.empty())    &#123;        node nod = que.front(); que.pop();        for (auto i = edges[nod.x].begin(); i != edges[nod.x].end(); i++)        &#123;            if ((*i) != nod.fa)            &#123;                que.emplace(node(*i, nod.x));                deep[*i] = deep[nod.x] + 1;                fa[*i][0] = nod.x;                for (int j = 1; (1 &lt;&lt; j) &lt;= deep[*i]; j++)                    fa[*i][j] = fa[fa[*i][j - 1]][j - 1];            &#125;        &#125;    &#125;&#125;int lca(int a, int b)&#123;    if (deep[a] &lt; deep[b])        swap(a, b);    if (!deep[b])        return b;    for (int i = MAXP; i &gt;= 0; i--)    &#123;        if (deep[fa[a][i]] &gt;= deep[b])            a = fa[a][i];        if (a == b)            return a;    &#125;    for (int i = MAXP; i &gt;= 0; i--)    &#123;        if (fa[a][i] != fa[b][i])        &#123;            a = fa[a][i];            b = fa[b][i];        &#125;    &#125;    return fa[a][0];&#125;int main()&#123;    int u, v;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);    for (int i = 1; i &lt; n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        edges[u].emplace_back(v);        edges[v].emplace_back(u);    &#125;    bfs(s);    int a, b;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        printf(&quot;%d\\n&quot;, lca(a, b));    &#125;    return 0;&#125;\n时间复杂度\n\n\\Theta{(n + nlog_2n + mlog_2n)} = \\Theta{((n + m)logn)}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n\n \n \n\n \n \n\n \n \n\n \n \n \n \n \n \n \n \n \n \n \n\n\n\n","plink":"https://oi.reqwey.me/algorithm-lca/"},{"title":"【Solution】[JSOI2008]最大数-ST表","date":"2020-01-15T00:00:00.000Z","date_formatted":{"ll":"Jan 15, 2020","L":"01/15/2020","MM-DD":"01-15"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n\n解题思路\n\n\n\\texttt{ST}\n\n\n\n\n\n \n \n\n 表\n\n令 \nst[ i ][ j ]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n 为 \n\\max \\limits_{1 \\leq t \\leq (i + 2^j - 1)} arr[t]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n\n\n \n \n \n \n \n \n \n\n \n \n\n \n \n \n\n \n \n \n \n \n \n\n\n每在序列 \narr\n\n\n\n\n\n \n \n \n\n 的后面加入一个新值(假设是 \narr[ n ]\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n\n)时\n它只会影响到一类 \nst[ i ][ j ]\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n\n 当且仅当\n\ni + 2^j - 1 = n\n\n\n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n \n \n \n\n\n也就是说，只会影响到所有终点为\nn\n\n\n\n\n \n\n的区间\n将上述式子变形得:\n\ni = n - 2^j + 1\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n\n \n \n\n \n \n\n\n所以，我们可以穷举这个\nj\n\n\n\n\n \n\n，使得 \n1 \\leq 2^j \\leq n\n\n\n\n\n\n\n\n\n \n \n\n \n \n\n \n \n\n\n那么就可以定出这个长为\nj\n\n\n\n\n \n\n，终点为\nn\n\n\n\n\n \n\n的区间:\n\nst[ i ][ j ] = st[ n - 2^j + 1 ][j]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n\n \n \n\n \n \n \n \n \n \n\n\nTalk is cheap, show me the code.\n123456789void insert(ll num) &#123;    n++;    st[n][0] = num; //初始化    for (int i = 1; (1 &lt;&lt; i) &lt;= n; i++) &#123;        int tmp = n - (1 &lt;&lt; i) + 1;        st[tmp][i] = max(st[tmp][i - 1], st[tmp + (1 &lt;&lt; (i - 1))][i - 1]);        //这里的tmp其实就是原文中的i, 同理，这里的i是原文中的j    &#125;&#125;\n12345// 返回的是长度为 l ，终点为 n 的区间最大值ll solve(int l) &#123;    int k = (int)(log(double(l)) / log(2.0));    return max(st[n - l + 1][k], st[n - (1 &lt;&lt; k) + 1][k]);&#125;\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int ASK_SZ = 200001, LOG = 50;int m;ll d, last_ans;int n;ll st[ASK_SZ][LOG];ll solve(int l);void insert(ll num);int main() &#123;    char op;    ll num;    cin &gt;&gt; m &gt;&gt; d;    for (int i = 1; i &lt;= m; i++) &#123;        cin &gt;&gt; op &gt;&gt; num;        if (op == &#x27;Q&#x27;) &#123;            cout &lt;&lt; (last_ans = solve(num)) &lt;&lt; &#x27;\\n&#x27;;        &#125;        else &#123;            insert((num + last_ans) % d);        &#125;    &#125;    return 0;&#125;ll solve(int l) &#123;    int k = (int)(log(double(l)) / log(2.0));    return max(st[n - l + 1][k], st[n - (1 &lt;&lt; k) + 1][k]);&#125;void insert(ll num) &#123;    n++;    st[n][0] = num;    for (int i = 1; (1 &lt;&lt; i) &lt;= n; i++) &#123;        int tmp = n - (1 &lt;&lt; i) + 1;        st[tmp][i] = max(st[tmp][i - 1], st[tmp + (1 &lt;&lt; (i - 1))][i - 1]);    &#125;&#125;","plink":"https://oi.reqwey.me/solution-luogu-1198/"},{"title":"【Solution】尼克的任务-DP","date":"2019-12-20T00:00:00.000Z","date_formatted":{"ll":"Dec 20, 2019","L":"12/20/2019","MM-DD":"12-20"},"updated":"2024-01-28T08:21:50.966Z","content":"题目传送门。\n\n解题思路\n错误示范\n\n第一眼看过去，便不难想到构造:\n令 \ndp[i]\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 表示从时间点 \n1\n\n\n\n\n \n\n ~ \ni\n\n\n\n\n \n\n 的最大空暇时间\n\n123456789for i in range(1, n):  if 第i分钟没有任务 :      dp[i] = dp[i - 1] + 1 #意思是第i分钟可以休息，前面用dp[i - 1]决定  else :      for j in maps[i]: #maps[i]数组存储结束时间正好在第i分钟的每一个任务的时长\t\t\tdp[i] = max(dp[i], dp[i - maps[i][j]])\t\t\t#意思是前i分钟的休息时间只能等于这个任务做之前的休息时间print(dp[n]) #输出dp[n]\n但是这样做显然会有一个问题：\n\ndp[i]\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 的计算只考虑了这个时间点做完的任务, 也就是说, 可能 Nick 直到下班了也没有做完任务, 此时做最后一项任务的时间段也会被算为空暇时间.\n有没有什么改进的方法呢？答案是肯定的，那就是倒着 DP。\n令 \ndp[i]\n\n\n\n\n\n\n\n\n \n \n \n \n \n\n 表示从时间点 \ni\n\n\n\n\n \n\n ~ \nn\n\n\n\n\n \n\n 的最大空暇时间\n这样做的好处在于, 它考虑的不再是做完的时间, 而变成了每个任务的开始时间(Nick 总不会勤奋到提前几分钟开始工作吧), 这样就完美的避免了以上那个问题.\n123456789for i in range(n, 1, -1): #倒着循环  if 第i分钟没有任务 :      dp[i] = dp[i + 1] + 1 #意思是第i分钟可以休息，后面用dp[i + 1]决定  else :      for j in maps[i]: #maps[i]数组存储开始时间正好在第i分钟的每一个任务的结束时间\t\t\tdp[i] = max(dp[i], dp[i + maps[i][j]])\t\t\t#意思是后i分钟的休息时间只能等于这个任务做完后的休息时间print(dp[1]) #输出dp[1]\n完整代码\nCode123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int SIZE = 100001;int n, k;int dp[SIZE];vector &lt;int&gt; maps[SIZE];int main() &#123;    int start, do_time;    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= k; i++) &#123;        cin &gt;&gt; start &gt;&gt; do_time;        maps[start].push_back(do_time);    &#125;    for (int i = n; i &gt;= 1; i--) &#123;        int tmp = maps[i].size();        if (tmp) &#123;            for (int j = 0; j &lt; tmp; j++) &#123;                dp[i] = max(dp[i], dp[i + maps[i][j]]);            &#125;        &#125; else &#123;            dp[i] = dp[i + 1] + 1;        &#125;    &#125;    cout &lt;&lt; dp[1];    return 0;&#125;\n","plink":"https://oi.reqwey.me/solution-luogu-1280/"},{"title":"英语作业备忘录","date":"1970-01-01T00:00:00.000Z","date_formatted":{"ll":"Jan 1, 1970","L":"01/01/1970","MM-DD":"01-01"},"updated":"2024-01-28T08:21:50.966Z","content":"\n书本 P39 表格， Activity 3的第2、3小题。\n练习册\n书本 P40-41 包括41.4\n\n","plink":"https://oi.reqwey.me/english-homework/"},{"title":"关于我","date":"2024-01-28T16:21:50.966Z","date_formatted":{"ll":"Jan 28, 2024","L":"01/28/2024","MM-DD":"01-28"},"updated":"2024-01-28T08:21:50.966Z","content":"\nReqwey，读作 /Rekwi:/\n现在高三，前信息学竞赛、数学竞赛、物理竞赛选手.\n前往 我的 GitHub 主页 看看我最近干了啥。\n\n本站信息源文件 位于 GitHub，使用 GitHub Actions CI/CD 自动化部署 \n部署后的网站 托管于 Cloudflare Pages\n","plink":"https://oi.reqwey.me/about/"},{"title":"友情链接","date":"2024-01-28T16:21:50.966Z","date_formatted":{"ll":"Jan 28, 2024","L":"01/28/2024","MM-DD":"01-28"},"updated":"2024-01-28T08:21:50.966Z","content":"\n如果想加的话请联系我的 Telegram，谢谢（QAQ）\n\nSpecial list\n\nFYMS-OI\n\nFriends，forever！\n\nSoraStar\nJoy’s Blog\nSky390\n醉里博客\n欢乐小王\nIslauso\nJalenz\nCharlie\nUncle Drew\nxaoxuu\nVince\nColsch\nCode Young\nMHuiG\n枋柚梓\n尼采般地抒情\nSanarous\nQinxs\n\n","plink":"https://oi.reqwey.me/friends/"},{"title":"领取 350 元现金！","date":"2024-01-28T16:21:50.966Z","date_formatted":{"ll":"Jan 28, 2024","L":"01/28/2024","MM-DD":"01-28"},"updated":"2024-01-28T08:21:50.966Z","content":"\n \n\n","plink":"https://oi.reqwey.me/never/"}]